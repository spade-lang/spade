pub trait Number<#uint N> {}

impl<#uint N> Number<N> for uint<N> {}
impl<#uint N> Number<N> for int<N> {}

#[spadec_paren_sugar]
pub trait Fn<Args, Output> {
    fn call(self, args: Args) -> Output;
}

#[spadec_paren_sugar]
pub trait Entity<Args, Output> {
    fn call(self, clk: clock, args: Args) -> Output;
}

#[spadec_paren_sugar]
pub trait Pipeline<#int Depth, Args, Output> {
    pipeline(Depth) call(self, clk: clock, args: Args) -> Output;
}

pub trait PartialEq {
    fn eq(self, rhs: Self) -> bool;
    fn ne(self, rhs: Self) -> bool;
}

impl PartialEq for bool {
    #[inline]
    fn eq(self, rhs: Self) -> bool {
        intrinsics::eq(self, rhs)
    }

    #[inline]
    fn ne(self, rhs: Self) -> bool {
        intrinsics::ne(self, rhs)
    }
}

impl<#uint N> PartialEq for int<N> {
    #[inline]
    fn eq(self, rhs: Self) -> bool {
        intrinsics::eq(self, rhs)
    }

    #[inline]
    fn ne(self, rhs: Self) -> bool {
        intrinsics::ne(self, rhs)
    }
}

impl<#uint N> PartialEq for uint<N> {
    #[inline]
    fn eq(self, rhs: Self) -> bool {
        intrinsics::eq(self, rhs)
    }

    #[inline]
    fn ne(self, rhs: Self) -> bool {
        intrinsics::ne(self, rhs)
    }
}

impl<#uint N, T: PartialEq> PartialEq for [T; N] {
    #[inline]
    fn eq(self, rhs: Self) -> bool {
        intrinsics::eq(self, rhs)
    }

    #[inline]
    fn ne(self, rhs: Self) -> bool {
        intrinsics::ne(self, rhs)
    }
}

pub trait WrappingNeg {
    fn wrapping_neg(self) -> Self;
}

impl<#uint N> WrappingNeg for int<N> {
    fn wrapping_neg(self) -> Self {
        unsafe {
            let bits: [bool; N] = lib::conv::transmute(-self);
            lib::conv::transmute(bits[0..N])
        }
    }
}

pub trait WrappingAdd {
    fn wrapping_add(self, rhs: Self) -> Self;
}

impl<#uint N> WrappingAdd for int<N> {
    fn wrapping_add(self, rhs: Self) -> Self {
        unsafe {
            let bits: [bool; {N + 1}] = lib::conv::transmute(self + rhs);
            lib::conv::transmute(bits[0..N])
        }
    }
}

impl<#uint N> WrappingAdd for uint<N> {
    fn wrapping_add(self, rhs: Self) -> Self {
        unsafe {
            let bits: [bool; {N + 1}] = lib::conv::transmute(self + rhs);
            lib::conv::transmute(bits[0..N])
        }
    }
}

pub trait WrappingSub {
    fn wrapping_sub(self, rhs: Self) -> Self;
}

impl<#uint N> WrappingSub for int<N> {
    fn wrapping_sub(self, rhs: Self) -> Self {
        unsafe {
            let bits: [bool; {N + 1}] = lib::conv::transmute(self - rhs);
            lib::conv::transmute(bits[0..N])
        }
    }
}

impl<#uint N> WrappingSub for uint<N> {
    fn wrapping_sub(self, rhs: Self) -> Self {
        unsafe {
            let bits: [bool; {N + 1}] = lib::conv::transmute(self - rhs);
            lib::conv::transmute(bits[0..N])
        }
    }
}

pub trait WrappingMul {
    fn wrapping_mul(self, rhs: Self) -> Self;
}

impl<#uint N> WrappingMul for int<N> {
    fn wrapping_mul(self, rhs: Self) -> Self {
        unsafe {
            let bits: [bool; {2 * N}] = lib::conv::transmute(self * rhs);
            lib::conv::transmute(bits[0..N])
        }
    }
}

impl<#uint N> WrappingMul for uint<N> {
    fn wrapping_mul(self, rhs: Self) -> Self {
        unsafe {
            let bits: [bool; {2 * N}] = lib::conv::transmute(self * rhs);
            lib::conv::transmute(bits[0..N])
        }
    }
}

pub trait WrappingShl {
    fn wrapping_shl(self, rhs: Self) -> Self;
}

impl<#uint N> WrappingShl for int<N> {
    fn wrapping_shl(self, rhs: Self) -> Self {
        self << rhs
    }
}

impl<#uint N> WrappingShl for uint<N> {
    fn wrapping_shl(self, rhs: Self) -> Self {
        self << rhs
    }
}

pub trait WrappingShr {
    fn wrapping_shr(self, rhs: Self) -> Self;
}

impl<#uint N> WrappingShr for int<N> {
    fn wrapping_shr(self, rhs: Self) -> Self {
        self >> rhs
    }
}

impl<#uint N> WrappingShr for uint<N> {
    fn wrapping_shr(self, rhs: Self) -> Self {
        self >> rhs
    }
}

pub trait Not {
    fn not(self) -> Self;
}

impl Not for bool {
    #[inline]
    fn not(self) -> Self {
        intrinsics::bit_not([self])[0]
    }
}

pub trait BitNot {
    fn bit_not(self) -> Self;
}

impl<#uint N> BitNot for [bool; N] {
    #[inline]
    fn bit_not(self) -> Self {
        intrinsics::bit_not(self)
    }
}

impl<#uint N> BitNot for int<N> {
    #[inline]
    fn bit_not(self) -> Self {
        unsafe {
            let bits: [bool; N] = lib::conv::transmute(self);
            lib::conv::transmute(intrinsics::bit_not(bits))
        }
    }
}

impl<#uint N> BitNot for uint<N> {
    #[inline]
    fn bit_not(self) -> Self {
        unsafe {
            let bits: [bool; N] = lib::conv::transmute(self);
            lib::conv::transmute(intrinsics::bit_not(bits))
        }
    }
}

pub trait And {
    fn and(self, rhs: Self) -> Self;
}

impl And for bool {
    #[inline]
    fn and(self, rhs: Self) -> Self {
        intrinsics::bit_and([self], [rhs])[0]
    }
}

pub trait BitAnd {
    fn bit_and(self, rhs: Self) -> Self;
}

impl<#uint N> BitAnd for [bool; N] {
    #[inline]
    fn bit_and(self, rhs: Self) -> Self {
        intrinsics::bit_and(self, rhs)
    }
}

impl<#uint N> BitAnd for int<N> {
    #[inline]
    fn bit_and(self, rhs: Self) -> Self {
        unsafe {
            let lhs: [bool; N] = lib::conv::transmute(self);
            let rhs: [bool; N] = lib::conv::transmute(rhs);
            lib::conv::transmute(intrinsics::bit_and(lhs, rhs))
        }
    }
}

impl<#uint N> BitAnd for uint<N> {
    #[inline]
    fn bit_and(self, rhs: Self) -> Self {
        unsafe {
            let lhs: [bool; N] = lib::conv::transmute(self);
            let rhs: [bool; N] = lib::conv::transmute(rhs);
            lib::conv::transmute(intrinsics::bit_and(lhs, rhs))
        }
    }
}

pub trait Or {
    fn or(self, rhs: Self) -> Self;
}

impl Or for bool {
    #[inline]
    fn or(self, rhs: Self) -> Self {
        intrinsics::bit_or([self], [rhs])[0]
    }
}

pub trait BitOr {
    fn bit_or(self, rhs: Self) -> Self;
}

impl<#uint N> BitOr for [bool; N] {
    #[inline]
    fn bit_or(self, rhs: Self) -> Self {
        intrinsics::bit_or(self, rhs)
    }
}

impl<#uint N> BitOr for int<N> {
    #[inline]
    fn bit_or(self, rhs: Self) -> Self {
        unsafe {
            let lhs: [bool; N] = lib::conv::transmute(self);
            let rhs: [bool; N] = lib::conv::transmute(rhs);
            lib::conv::transmute(intrinsics::bit_or(lhs, rhs))
        }
    }
}

impl<#uint N> BitOr for uint<N> {
    #[inline]
    fn bit_or(self, rhs: Self) -> Self {
        unsafe {
            let lhs: [bool; N] = lib::conv::transmute(self);
            let rhs: [bool; N] = lib::conv::transmute(rhs);
            lib::conv::transmute(intrinsics::bit_or(lhs, rhs))
        }
    }
}

pub trait Xor {
    fn xor(self, rhs: Self) -> Self;
}

impl Xor for bool {
    #[inline]
    fn xor(self, rhs: Self) -> Self {
        intrinsics::bit_xor([self], [rhs])[0]
    }
}

pub trait BitXor {
    fn bit_xor(self, rhs: Self) -> Self;
}

impl<#uint N> BitXor for [bool; N] {
    #[inline]
    fn bit_xor(self, rhs: Self) -> Self {
        intrinsics::bit_xor(self, rhs)
    }
}

impl<#uint N> BitXor for int<N> {
    #[inline]
    fn bit_xor(self, rhs: Self) -> Self {
        unsafe {
            let lhs: [bool; N] = lib::conv::transmute(self);
            let rhs: [bool; N] = lib::conv::transmute(rhs);
            lib::conv::transmute(intrinsics::bit_xor(lhs, rhs))
        }
    }
}

impl<#uint N> BitXor for uint<N> {
    #[inline]
    fn bit_xor(self, rhs: Self) -> Self {
        unsafe {
            let lhs: [bool; N] = lib::conv::transmute(self);
            let rhs: [bool; N] = lib::conv::transmute(rhs);
            lib::conv::transmute(intrinsics::bit_xor(lhs, rhs))
        }
    }
}

pub trait PartialOrd: PartialEq {
    fn lt(self, rhs: Self) -> bool;
    fn le(self, rhs: Self) -> bool;
    fn gt(self, rhs: Self) -> bool;
    fn ge(self, rhs: Self) -> bool;
}

impl<#uint N> PartialOrd for int<N> {
    #[inline]
    fn lt(self, rhs: Self) -> bool {
        intrinsics::lt(self, rhs)
    }

    #[inline]
    fn le(self, rhs: Self) -> bool {
        intrinsics::le(self, rhs)
    }

    #[inline]
    fn gt(self, rhs: Self) -> bool {
        intrinsics::gt(self, rhs)
    }

    #[inline]
    fn ge(self, rhs: Self) -> bool {
        intrinsics::ge(self, rhs)
    }
}

impl<#uint N> PartialOrd for uint<N> {
    #[inline]
    fn lt(self, rhs: Self) -> bool {
        intrinsics::lt(self, rhs)
    }

    #[inline]
    fn le(self, rhs: Self) -> bool {
        intrinsics::le(self, rhs)
    }

    #[inline]
    fn gt(self, rhs: Self) -> bool {
        intrinsics::gt(self, rhs)
    }

    #[inline]
    fn ge(self, rhs: Self) -> bool {
        intrinsics::ge(self, rhs)
    }
}

mod intrinsics {
    pub(super) extern fn eq<T>(lhs: T, rhs: T) -> bool;
    pub(super) extern fn ne<T>(lhs: T, rhs: T) -> bool;

    pub(super) extern fn bit_not<#uint N>(val: [bool; N]) -> [bool; N];
    pub(super) extern fn bit_and<#uint N>(lhs: [bool; N], rhs: [bool; N]) -> [bool; N];
    pub(super) extern fn bit_or<#uint N>(lhs: [bool; N], rhs: [bool; N]) -> [bool; N];
    pub(super) extern fn bit_xor<#uint N>(lhs: [bool; N], rhs: [bool; N]) -> [bool; N];

    pub(super) extern fn lt<#uint N, T: Number<N>>(lhs: T, rhs: T) -> bool;
    pub(super) extern fn le<#uint N, T: Number<N>>(lhs: T, rhs: T) -> bool;
    pub(super) extern fn gt<#uint N, T: Number<N>>(lhs: T, rhs: T) -> bool;
    pub(super) extern fn ge<#uint N, T: Number<N>>(lhs: T, rhs: T) -> bool;
}
